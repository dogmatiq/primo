package generator

import (
	"fmt"
	"path"
	"strings"

	"github.com/dave/jennifer/jen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

type fileScope struct {
	GeneratorVersion string
	Request          *pluginpb.CodeGeneratorRequest
	Types            map[string]jen.Code
	Parameters       parameters
	FileDescriptor   *descriptorpb.FileDescriptorProto
}

func (s *fileScope) Generate() (*pluginpb.CodeGeneratorResponse_File, error) {
	pkgPath, pkgName, err := goPackage(s.FileDescriptor)
	if err != nil {
		return nil, err
	}

	code := jen.NewFilePathName(pkgPath, pkgName)
	code.HeaderComment("Code generated by protoc-gen-go-primo. DO NOT EDIT.")
	code.HeaderComment("versions:")
	code.HeaderComment(fmt.Sprintf("// 	protoc-gen-go-primo v%s", s.GeneratorVersion))
	code.HeaderComment(fmt.Sprintf("// 	protoc              v%s", s.compilerVersion()))
	code.HeaderComment(fmt.Sprintf("// source: %s", s.FileDescriptor.GetName()))

	for _, md := range s.FileDescriptor.GetMessageType() {
		ms := &messageScope{
			fileScope:         s,
			MessageDescriptor: md,
		}

		if err := ms.Generate(code); err != nil {
			return nil, err
		}
	}

	w := &strings.Builder{}
	if err := code.Render(w); err != nil {
		return nil, err
	}

	return &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(s.outputFileName()),
		Content: proto.String(w.String()),
	}, nil
}

// goPackage parses the "go_package" option in the file and returns
// the import path and unqualified package name.
func goPackage(fd *descriptorpb.FileDescriptorProto) (string, string, error) {
	pkg := fd.GetOptions().GetGoPackage()
	if pkg == "" {
		return "", "", fmt.Errorf("%s does not specify a 'go_package' option", fd.GetName())
	}

	// If a semi-colon is present, the part after the semi-colon is the actual
	// package name. Used when the import path and package name differ.
	//
	// Use of this option is discouraged. See
	// https://developers.google.com/protocol-buffers/docs/reference/go-generated
	if i := strings.Index(pkg, ";"); i != -1 {
		return pkg[:i], pkg[i+1:], nil
	}

	return pkg, path.Base(pkg), nil
}

// outputFileName returns the name of the file to generate.
func (s *fileScope) outputFileName() string {
	n := strings.TrimPrefix(s.FileDescriptor.GetName(), s.Parameters.Module)

	if ext := path.Ext(n); ext == ".proto" || ext == ".protodevel" {
		n = strings.TrimSuffix(n, ext)
	}

	return n + "_primo.pb.go"
}

// compilerVersion returns the protoc version provided in the request for use in
// a file header.
func (s *fileScope) compilerVersion() string {
	ver := s.Request.GetCompilerVersion()
	str := fmt.Sprintf(
		"%d.%d.%d",
		ver.GetMajor(),
		ver.GetMinor(),
		ver.GetPatch(),
	)

	if suffix := ver.GetSuffix(); suffix != "" {
		str += "-" + suffix
	}

	return str
}
